Q1:Not boring movies:

Write a solution to report the movies with an odd-numbered ID and a description that is not "boring".
Return the result table ordered by rating in descending order.

Example 1:

Input: 
Cinema table:
+----+------------+-------------+--------+
| id | movie      | description | rating |
+----+------------+-------------+--------+
| 1  | War        | great 3D    | 8.9    |
| 2  | Science    | fiction     | 8.5    |
| 3  | irish      | boring      | 6.2    |
| 4  | Ice song   | Fantacy     | 8.6    |
| 5  | House card | Interesting | 9.1    |
+----+------------+-------------+--------+
Output: 
+----+------------+-------------+--------+
| id | movie      | description | rating |
+----+------------+-------------+--------+
| 5  | House card | Interesting | 9.1    |
| 1  | War        | great 3D    | 8.9    |
+----+------------+-------------+--------+
---------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

SELECT *                               -- Selects all columns from the Cinema table
FROM cinema                            -- Specifies the Cinema table as the data source
WHERE id % 2 != 0                      -- Filters movies with an odd id (id is not divisible by 2)
  AND description <> 'boring'          -- Excludes movies where the description is 'boring'
ORDER BY rating DESC;                  -- Orders the results by rating in descending order
---------------------------------------------------------------------------------------------------------------------------------------------------------
üéØTips!
1- Purpose:
This query retrieves movies with odd IDs, excludes those described as 'boring', and sorts them by rating in descending order.

2-Why Use Modulo (%):ü§∑‚Äç‚ôÄ
The modulo operator is a common and efficient way to filter odd or even values. It's simple and easy to understand.

3-<> for Exclusion:
<> is SQL's standard inequality operator, ensuring the query excludes unwanted rows (e.g., movies described as 'boring').

4-Best Practices:
Use SELECT * sparingly and specify required columns for better performance and clarity.
Always document the logic behind filters (e.g., why odd IDs are selected).

5-Real-World Use Case:
This query is suitable for scenarios like filtering and ranking movies in a database for recommendations.
*************************************************************************************************************************************************************************************
Q2: Average selling price:

Write a solution to find the average selling price for each product. average_price should be rounded to 2 decimal places. 
If a product does not have any sold units, its average selling price is assumed to be 0.
Return the result table in any order.

Example 1:

Input: 
Prices table:
+------------+------------+------------+--------+
| product_id | start_date | end_date   | price  |
+------------+------------+------------+--------+
| 1          | 2019-02-17 | 2019-02-28 | 5      |
| 1          | 2019-03-01 | 2019-03-22 | 20     |
| 2          | 2019-02-01 | 2019-02-20 | 15     |
| 2          | 2019-02-21 | 2019-03-31 | 30     |
+------------+------------+------------+--------+
UnitsSold table:
+------------+---------------+-------+
| product_id | purchase_date | units |
+------------+---------------+-------+
| 1          | 2019-02-25    | 100   |
| 1          | 2019-03-01    | 15    |
| 2          | 2019-02-10    | 200   |
| 2          | 2019-03-22    | 30    |
+------------+---------------+-------+
Output: 
+------------+---------------+
| product_id | average_price |
+------------+---------------+
| 1          | 6.96          |
| 2          | 16.96         |
+------------+---------------+
---------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

-- Selects the product ID from the Prices table
-- Rounds the calculated average price to 2 decimal places
-- Handles NULL values by returning 0 if there are no matching units sold
SELECT p.product_id, ROUND( IFNULL( SUM(p.price * u.units) / SUM(u.units), 0), 2) AS average_price     -- Alias for the calculated average price
                                         
FROM prices p                                                                                          -- Prices table containing product prices and date ranges
LEFT JOIN unitssold u                                                                                  -- LEFT JOIN ensures all products are included, even if no units were sold
ON p.product_id = u.product_id                                                                         -- Matches product IDs between Prices and UnitsSold
   AND u.purchase_date BETWEEN p.start_date AND p.end_date                                             -- Ensures the units sold fall within the valid price date range
GROUP BY p.product_id;                                                                                 -- Groups results by product ID for aggregation
---------------------------------------------------------------------------------------------------------------------------------------------------------
üéØTips!
1-Purpose:
This query calculates the average price per product based on units sold during valid price periods, handling cases where no units were sold.

2-Handling NULL Values with IFNULL:
If no matching records are found in the unitssold table (e.g., no units sold for a product), the IFNULL function ensures the average price is set to 0 instead of NULL.

3-Why Use LEFT JOIN?ü§∑‚Äç‚ôÄÔ∏è
Ensures all products in the prices table are included in the result, even if there are no sales records in the unitssold table.

4-Date Range Filter:
The BETWEEN p.start_date AND p.end_date condition ensures that only units sold during the valid price period are included in the calculation.

5-Aggregation and Rounding:
SUM(p.price * u.units) / SUM(u.units): Calculates the weighted average price per product based on units sold.
ROUND(..., 2): Rounds the result to two decimal places for better readability.

6-GROUP BY:
Groups by p.product_id to compute the average price for each product individually.

7-Real-World Use Case:
This query is useful for analyzing product pricing trends, such as determining the effective price customers paid during a specific period.

üëå Key Takeaways:

üéáData Integration:
Combines data from two tables (prices and unitssold) to calculate weighted averages.

üéáNULL Handling:
Demonstrates the importance of handling missing data using IFNULL.

üéáScalability:
This pattern can be adapted for other weighted average calculations, such as revenue per unit or cost per item.

üéáSQL Best Practices:
Filters and conditions (e.g., BETWEEN) ensure only relevant data is included in the analysis.
Aggregations (SUM) and rounding improve clarity and precision.
*************************************************************************************************************************************************************************************
Q3: Project employees I:

Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.
Return the result table in any order.

Example 1:

Input: 
Project table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+
Employee table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 1                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+
Output: 
+-------------+---------------+
| project_id  | average_years |
+-------------+---------------+
| 1           | 2.00          |
| 2           | 2.50          |
+-------------+---------------+
---------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

SELECT p.project_id, ROUND(AVG(e.experience_years), 2) AS average_years             -- Calculates the average experience years for each project, rounded to 2 decimal places                             
       
FROM project p                                                                      -- Project table containing project and employee mappings
JOIN employee e                                                                     -- Employee table containing employee details, including experience years
ON p.employee_id = e.employee_id                                                    -- Joins Project and Employee tables based on employee_id
GROUP BY p.project_id;                                                              -- Groups the result by project ID to calculate the average for each project
---------------------------------------------------------------------------------------------------------------------------------------------------------
üéØTips!

1-JOIN:
Combines the Project table with the Employee table using the employee_id column, allowing access to employee experience years for each project.

2-AVG:
Calculates the average of experience_years for all employees associated with each project.

3-ROUND:
Rounds the calculated average to 2 decimal places for better readability and compliance with the output format.

4-GROUP BY:
Groups the data by project_id, ensuring that the average is calculated for each project separately.

üëå Key Takeaways:

üéáPurpose:
The query calculates the average experience years of all employees for each project, ensuring accurate and formatted results.

üéáWhy Use JOIN?
Combines project and employee data, making it possible to calculate experience years for each project based on employee participation.

üéáAggregation with AVG:
The AVG function is perfect for scenarios requiring average calculations over grouped data.

üéáRounding with ROUND:
Ensures consistency in output formatting (e.g., 2 decimal places), improving presentation and usability.

üéáGROUP BY for Aggregation:
Ensures the calculation of averages for each unique project (project_id).

üéáPerformance Considerations:
Use appropriate indexing (e.g., on employee_id and project_id) to optimize performance, especially for large datasets.
*************************************************************************************************************************************************************************************
Q4: Percentage of users attended a contest:

Write a solution to find the percentage of the users registered in each contest rounded to two decimals.
Return the result table ordered by percentage in descending order. 
In case of a tie, order it by contest_id in ascending order.

Example 1:

Input: 
Users table:
+---------+-----------+
| user_id | user_name |
+---------+-----------+
| 6       | Alice     |
| 2       | Bob       |
| 7       | Alex      |
+---------+-----------+
Register table:
+------------+---------+
| contest_id | user_id |
+------------+---------+
| 215        | 6       |
| 209        | 2       |
| 208        | 2       |
| 210        | 6       |
| 208        | 6       |
| 209        | 7       |
| 209        | 6       |
| 215        | 7       |
| 208        | 7       |
| 210        | 2       |
| 207        | 2       |
| 210        | 7       |
+------------+---------+
Output: 
+------------+------------+
| contest_id | percentage |
+------------+------------+
| 208        | 100.0      |
| 209        | 100.0      |
| 210        | 100.0      |
| 215        | 66.67      |
| 207        | 33.33      |
+------------+------------+
---------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:

SELECT r.contest_id,                                      
       ROUND(COUNT(DISTINCT r.user_id) * 100.0 /           -- Calculates the percentage of registered users
             (SELECT COUNT(DISTINCT u.user_id)             -- Total number of unique users from the Users table
              FROM users u), 2) AS percentage              -- Rounds the percentage to two decimal places
FROM register r                                            -- Register table containing contest-user mappings
GROUP BY r.contest_id                                      -- Groups results by contest ID for aggregation
ORDER BY percentage DESC,                                  -- Orders by percentage in descending order
         r.contest_id ASC;                                 -- Orders by contest ID in ascending order in case of a tie
---------------------------------------------------------------------------------------------------------------------------------------------------------
üéØTips!

1-Purpose:
Calculate the percentage of total users who registered for each contest.

2-Key Steps:
   a.Count Registered Users:
    COUNT(DISTINCT r.user_id) counts unique users registered for each contest.
   b.Total Users:
    (SELECT COUNT(DISTINCT u.user_id) FROM users u) calculates the total number of distinct users from the Users table.
   c.Percentage:
    Multiplies the count of registered users by 100.0 and divides by the total users to compute the percentage.
   d.Rounding:
    ROUND(..., 2) ensures the result is rounded to two decimal places.
3-GROUP BY:
Groups the data by contest_id to compute the percentage for each contest.

4-ORDER BY:
Orders the result by:
   a.percentage DESC: Descending order of percentage.
   b.contest_id ASC: Ascending order of contest_id to resolve ties.

üëå Key Takeaways:

üéáData Aggregation:
Demonstrates the use of COUNT, DISTINCT, and GROUP BY for summarizing data.

üéáSubquery Usage:
Shows how to calculate a total value (total users) for percentage calculations.

üéáAdvanced Sorting:
Includes multiple sorting criteria for ranked output.

üéáSQL Best Practices:
Uses ROUND for consistent formatting and ensures no duplicate counts with DISTINCT.
*************************************************************************************************************************************************************************************



















































