Q1: Replace employee ID with the unique identifier

Write a solution to show the unique ID of each user, If a user does not have a unique ID replace just show null.
Return the result table in any order.

Example 1:

Input: 
Employees table:
+----+----------+
| id | name     |
+----+----------+
| 1  | Alice    |
| 7  | Bob      |
| 11 | Meir     |
| 90 | Winston  |
| 3  | Jonathan |
+----+----------+
EmployeeUNI table:
+----+-----------+
| id | unique_id |
+----+-----------+
| 3  | 1         |
| 11 | 2         |
| 90 | 3         |
+----+-----------+
Output: 
+-----------+----------+
| unique_id | name     |
+-----------+----------+
------------------------------------------------------------------------------------
Solution:

SELECT IFNULL(employeeuni.unique_id, NULL) AS unique_id,                   -- Selects the unique_id from EmployeeUNI or NULL if no match
       employees.name                                                      -- Selects the name of the employee from Employees
FROM employees                                                             -- Specifies the Employees table as the main (left) table
LEFT JOIN employeeuni                                                      -- Performs a LEFT JOIN to include all rows from Employees
ON employees.id = employeeuni.id;                                          -- Matches rows where the id from Employees equals the id from EmployeeUNI
------------------------------------------------------------------------------------
🎯 Tips:

1-Why Use LEFT JOIN?🤷‍♀️
⁕ Use LEFT JOIN when you need all rows from the left table (Employees), regardless of whether there is a match in the right table (EmployeeUNI).
2-IFNULL Clarification:
⁕ The IFNULL function is optional in this case because LEFT JOIN will already produce NULL for unmatched rows. However, including it explicitly can make the intent 
clearer.
3-Improving Readability:
⁕ If you don’t need to explicitly use IFNULL, you can simplify the query by directly selecting employeeuni.unique_id since unmatched rows will naturally result in 
NULL.
4-Potential Use Case:
⁕ This query is helpful for identifying employees who don’t have an associated unique_id in the EmployeeUNI table (those rows will have NULL in the unique_id column).

*********************************************************************************************************************************************************************
Q2: Product sales analysis:

Write a solution to report the product_name, year, and price for each sale_id in the Sales table.
Return the resulting table in any order.

Example 1:

Input: 
Sales table:
+---------+------------+------+----------+-------+
| sale_id | product_id | year | quantity | price |
+---------+------------+------+----------+-------+ 
| 1       | 100        | 2008 | 10       | 5000  |
| 2       | 100        | 2009 | 12       | 5000  |
| 7       | 200        | 2011 | 15       | 9000  |
+---------+------------+------+----------+-------+
Product table:
+------------+--------------+
| product_id | product_name |
+------------+--------------+
| 100        | Nokia        |
| 200        | Apple        |
| 300        | Samsung      |
+------------+--------------+
Output: 
+--------------+-------+-------+
| product_name | year  | price |
+--------------+-------+-------+
| Nokia        | 2008  | 5000  |
| Nokia        | 2009  | 5000  |
| Apple        | 2011  | 9000  |
+--------------+-------+-------+
------------------------------------------------------------------------------------
Solution: 
SELECT p.product_name,                                            -- Selects the name of the product from the Product table
       s.year,                                                    -- Selects the year of the sale from the Sales table
       s.price                                                    -- Selects the price of the product from the Sales table
FROM sales s                                                      -- Specifies the Sales table (aliased as 's') as the primary table
JOIN product p                                                    -- Performs an INNER JOIN with the Product table (aliased as 'p')
ON s.product_id = p.product_id;                                   -- Matches rows where product_id in Sales equals product_id in Product
***************************************************************************************************************************************************
Q3: Customer who visited but didn't make any transactions:

Write a solution to find the IDs of the users who visited without making any transactions and the number of times they made these types of visits.
Return the result table sorted in any order.

Example 1:

Input: 
Visits
+----------+-------------+
| visit_id | customer_id |
+----------+-------------+
| 1        | 23          |
| 2        | 9           |
| 4        | 30          |
| 5        | 54          |
| 6        | 96          |
| 7        | 54          |
| 8        | 54          |
+----------+-------------+
Transactions
+----------------+----------+--------+
| transaction_id | visit_id | amount |
+----------------+----------+--------+
| 2              | 5        | 310    |
| 3              | 5        | 300    |
| 9              | 5        | 200    |
| 12             | 1        | 910    |
| 13             | 2        | 970    |
+----------------+----------+--------+
Output: 
+-------------+----------------+
| customer_id | count_no_trans |
+-------------+----------------+
| 54          | 2              |
| 30          | 1              |
| 96          | 1              |
+-------------+----------------+
------------------------------------------------------------------------------------
Solution:
SELECT v.customer_id,                                  -- Selects the customer ID from the Visits table
       COUNT(v.customer_id) AS count_no_trans          -- Counts the number of visits without transactions for each customer
FROM visits v                                          -- Specifies the Visits table (aliased as 'v') as the main table
LEFT JOIN transactions t                               -- Performs a LEFT JOIN with the Transactions table (aliased as 't')
ON v.visit_id = t.visit_id                             -- Matches rows where the visit_id in Visits equals visit_id in Transactions
WHERE t.transaction_id IS NULL                         -- Filters only rows where there is no matching transaction (no transaction_id)
GROUP BY v.customer_id;                                -- Groups the result by customer ID to calculate counts per customer
------------------------------------------------------------------------------------
🎯 Tips: 

Why a LEFT JOIN is Used?:🤷‍♀️
1- Include All Rows from the Left Table:
🎇A LEFT JOIN ensures that all rows from the Visits table are included in the result, even if there is no corresponding entry in the Transactions table.

2-Identify Missing Matches:
🎇Rows where t.transaction_id is NULL indicate visits that do not have an associated transaction. 
This behavior is key to identifying customers with visits but no transactions.

3-Preserve Data Integrity:
🎇Using a LEFT JOIN prevents the exclusion of rows from Visits, which might happen with an INNER JOIN. 
This ensures we do not lose any customers or visits when analyzing missing transactions.

4-Filtering with WHERE t.transaction_id IS NULL:🤷‍♀️ 
🎇The WHERE clause specifically focuses on the rows where no match exists in the Transactions table, which is crucial for the intended analysis.

5-Group and Aggregate:🤷‍♀️
🎇The GROUP BY clause groups the data by customer_id, allowing the COUNT function to compute the number of visits without transactions for each customer.
***************************************************************************************************************************************************
Q4: Rising temperature:

Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday).
Return the result table in any order.

Example 1:
Input: 
Weather table:
+----+------------+-------------+
| id | recordDate | temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+
Output: 
+----+
| id |
+----+
| 2  |
| 4  |
+----+
------------------------------------------------------------------------------------
Solution:
SELECT w1.id                                                             -- Selects the ID of the weather record from the first instance of the Weather table (w1)
FROM weather w1                                                          -- Refers to the Weather table as w1 (alias for clarity)
JOIN weather w2                                                          -- Performs an INNER JOIN with a second instance of the Weather table (w2)
ON w1.recordDate = DATE_ADD(w2.recordDate, INTERVAL 1 DAY)               -- Matches rows where w1's recordDate is 1 day after w2's recordDate
WHERE w1.temperature > w2.temperature;                                   -- Filters for cases where w1's temperature is higher than w2's
------------------------------------------------------------------------------------
🎯 Tips: 
1-Use Case:
This query demonstrates a self-join to compare rows within the same table. It’s commonly used for trend analysis 
(e.g., finding days with increasing temperature).
2-Why Use JOIN?:
The self-join allows comparing rows with specific relationships (e.g., consecutive dates) within a single table.
Importance of DATE_ADD:
3-Using the DATE_ADD function simplifies date arithmetic, ensuring the query works with properly formatted date columns.
4-Performance Tip:
If the Weather table is large, ensure an index exists on the recordDate column to improve the performance of the join condition.
5-Output:
The query will return only the id values for rows in w1 where the temperature was higher than on the previous day.

👌Key Takeaways:
🎇Self-Join in Action:
This query is a classic example of using a self-join to compare related rows in the same table.
🎇Date Arithmetic:
Functions like DATE_ADD are essential for date-based comparisons.
🎇Scalability:
The query can be adapted to compare other columns or different date intervals.
🎇Practical Use Case:
This pattern is widely applicable in trend analysis, such as detecting consecutive days with specific conditions.
***************************************************************************************************************************************************
Q5: Average time of process of machine:
There is a factory website that has several machines each running the same number of processes. 
Write a solution to find the average time each machine takes to complete a process.
The time to complete a process is the 'end' timestamp minus the 'start' timestamp. 
The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.
The resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.
Return the result table in any order.

Example 1:
Input: 
Activity table:
+------------+------------+---------------+-----------+
| machine_id | process_id | activity_type | timestamp |
+------------+------------+---------------+-----------+
| 0          | 0          | start         | 0.712     |
| 0          | 0          | end           | 1.520     |
| 0          | 1          | start         | 3.140     |
| 0          | 1          | end           | 4.120     |
| 1          | 0          | start         | 0.550     |
| 1          | 0          | end           | 1.550     |
| 1          | 1          | start         | 0.430     |
| 1          | 1          | end           | 1.420     |
| 2          | 0          | start         | 4.100     |
| 2          | 0          | end           | 4.512     |
| 2          | 1          | start         | 2.500     |
| 2          | 1          | end           | 5.000     |
+------------+------------+---------------+-----------+
Output: 
+------------+-----------------+
| machine_id | processing_time |
+------------+-----------------+
| 0          | 0.894           |
| 1          | 0.995           |
| 2          | 1.456           |
+------------+-----------------+
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Solution:
-- Creates a Common Table Expression (CTE) to calculate the processing time for each process on each machine
WITH ProcessTimes AS ( 
    SELECT machine_id,                                                                                  -- Selects the machine ID
           process_id,                                                                                  -- Selects the process ID
           MAX(CASE WHEN activity_type = 'end' THEN timestamp END)                                      -- Finds the timestamp for the 'end' activity
           - MAX(CASE WHEN activity_type = 'start' THEN timestamp END) AS process_time                  -- Calculates the time difference between 'end' and 'start' activities for the process
    FROM Activity                                                                                       -- Uses the Activity table
    GROUP BY machine_id, process_id                                                                     -- Groups by machine and process to calculate processing time for each unique process
)
SELECT machine_id,                                                                                      -- Selects the machine ID for final output
       ROUND(AVG(process_time), 3) AS processing_time                                                   -- Calculates the average processing time for each machine and rounds it to 3 decimal places
FROM ProcessTimes                                                                                       -- Uses the CTE to calculate average processing time
GROUP BY machine_id;                                                                                    -- Groups by machine ID to calculate the average for each machine
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
🎯 Tips: 
1-Using a CTE (WITH ProcessTimes):
A Common Table Expression (CTE) simplifies the query by first calculating the processing time for each machine_id and process_id. 
This allows the second part of the query to focus on aggregating the results.
2-CASE with MAX:
The CASE statement extracts the timestamp values for specific activity_type conditions (start or end).
MAX is used because there can only be one start and one end per process, and it ensures the correct timestamp is used.
3-Processing Time Calculation:
The difference between the end and start timestamps (MAX(end) - MAX(start)) gives the processing time for each individual process.
4-Average Processing Time:
In the final query, the average processing time per machine is calculated using AVG(process_time) and rounded to 3 decimal places with ROUND.
5-Grouping:
Step 1: Group by machine_id and process_id in the CTE to calculate processing time for each process.
Step 2: Group by machine_id in the final query to calculate the average processing time for all processes on each machine.

👌Key Takeaways:

🎇Efficient Query Design:
Using a CTE simplifies the logic by breaking down the problem into manageable parts (process time calculation first, followed by averaging).
🎇CASE Expressions for Conditional Aggregation:
Demonstrates a powerful technique for calculating metrics based on specific conditions within a single query.
🎇Practical Use Case:
This query is applicable in real-world scenarios like manufacturing or data processing pipelines where monitoring process times is crucial.
🎇Code Modularity:
The CTE allows for reusability and easier debugging, making the query modular and maintainable.
***************************************************************************************************************************************************





















